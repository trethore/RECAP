./
	.clang-format:
		---
		# Start with a known base style and override to match observed conventions.
		BasedOnStyle: LLVM

		# Indentation settings
		IndentWidth: 4
		TabWidth: 4
		UseTab: Never

		ColumnLimit: 0

		# Keep the K&R/Attach brace style: opening braces on the same line.
		BreakBeforeBraces: Custom
		BraceWrapping:
		  AfterControlStatement: false
		  AfterEnum: false
		  AfterFunction: false
		  AfterNamespace: false
		  AfterStruct: false
		  AfterUnion: false
		  BeforeElse: true

		# Single-line if/for/while are allowed without braces (as seen in the code).
		AllowShortIfStatementsOnASingleLine: true
		AllowShortLoopsOnASingleLine: true
		AllowShortBlocksOnASingleLine: false

		MaxEmptyLinesToKeep: 2047

		# Space rules
		SpaceBeforeParens: ControlStatements # Space after 'if', 'while', etc., none before function calls
		SpaceAfterCStyleCast: false # (Type*)var, with no space

		# Pointer alignment: "char* ptr" (star bound to the type).
		PointerAlignment: Left

		# Turn off include sorting; keep them in the order as-is.
		SortIncludes: Never

		# This style tries not to reflow large comment blocks.
		ReflowComments: false

		# Typically recommended so that case labels align with switch statements
		# (K&R style).
		IndentCaseLabels: false
		---

	.git/
	.gitignore:
		obj/

		recap.exe
		recap
		recap-output*
		.env
	.vscode/
		settings.json:
			{
			    "files.associations": {
			        "ctf.h": "c",
			        "stat.h": "c",
			        "dirent.h": "c",
			        "stdio.h": "c",
			        "recap.h": "c",
			        "curl.h": "c",
			        "jansson.h": "c",
			        "stdlib.h": "c",
			        "string.h": "c",
			        "time.h": "c",
			        "limits.h": "c",
			        "unistd.h": "c",
			        "fnmatch.h": "c"
			    }
			}
	Makefile:
		PREFIX ?= /usr/local
		BINDIR := $(PREFIX)/bin
		MANDIR := $(PREFIX)/share/man/man1

		CC = gcc
		CFLAGS = -Wall -Wextra -std=gnu11 -g -D_POSIX_C_SOURCE=200809L
		LIBS = -lcurl -ljansson

		SRCDIR = src
		OBJDIR = obj
		EXEC = recap
		MANPAGE = doc/recap.1

		SOURCES = $(wildcard $(SRCDIR)/*.c) 
		OBJECTS = $(patsubst $(SRCDIR)/%.c,$(OBJDIR)/%.o,$(SOURCES))

		all: $(EXEC)

		# Link target
		$(EXEC): $(OBJECTS)
			$(CC) $(CFLAGS) $^ -o $@ $(LIBS)

		$(OBJDIR)/%.o: $(SRCDIR)/%.c $(SRCDIR)/recap.h | $(OBJDIR)
			$(CC) $(CFLAGS) -c $< -o $@

		$(OBJDIR):
			@mkdir -p $(OBJDIR)

		clean:
			rm -rf $(OBJDIR) $(EXEC)

		install: $(EXEC) $(MANPAGE)
			install -Dm755 $(EXEC) $(BINDIR)/$(EXEC)
			install -Dm644 $(MANPAGE) $(MANDIR)/$(EXEC).1
			@echo "$(EXEC): installed to $(BINDIR), manpage to $(MANDIR)"

		uninstall:
			rm -f $(BINDIR)/$(EXEC)
			rm -f $(MANDIR)/$(MANPAGE).1
			@echo "$(EXEC): uninstalled"

		.PHONY: all clean install uninstall
	README.md:
		# RECAP - Extracts Context And Packages

		## Purpose

		`recap` is a command-line tool designed to capture the structure and content of a workspace and consolidate it into a single text output. This output can be redirected to a file or piped directly, making it ideal for providing context to AI models that need to understand the project's layout and relevant code.

		## TODO

		* [X] Change `--paste` to check if an API key is provided in environment
		* [X] Add `--output` output the generated text in a file
		* [X] Add `--out-dir` output the generated text in a directory
		* [X] Add a warning to `--clear` since it removes all ctf-output files
		* [X] Remove `--name` no longer useful
		* [X] Remove `--dir` no longer useful
		* [X] Add `--version`
		* [X] `--content` allow multiple options instead of custom quote separation logic (current logic is fine, but what if you want to target extensions containing quotes? it's a rabbit hole of escaping mechanisms. better let the shell handle it)
		* [X] add non-option argument for source directory(ies?): currently it's always `.`
		* [X] Allow custom .gitignore filename as `--git` option argument, or load it from parent directory recursively (until root) if not found. Also check if there's a library to interpret the full syntax (comment, !-lines...)
		* [ ] Remove Herobrine
		  
		## Building the Project

		### Dependencies

		This project requires the following libraries:

		* libcurl (for HTTP requests)
		* jansson (for JSON parsing)

		On Debian/Ubuntu systems, you can install these dependencies with:

		```bash
		sudo apt-get install libcurl4-openssl-dev libjansson-dev
		```

		### Build Instructions

		1. Clone the repository:
		  
		  ```bash
		  git clone https://github.com/trethore/RECAP.git
		  cd RECAP
		  ```
		  
		2. Build the project:
		  
		  ```bash
		  make
		  ```
		  
		  This will compile the source files and create the `recap` executable.
		  
		3. To clean the build files:
		  
		  ```bash
		  make clean
		  ```

		### Build Configuration

		The project is compiled with the following flags:

		* `-Wall -Wextra`: Enable all warnings
		* `-std=c11`: Use C11 standard
		* `-g`: Include debugging information

		If you need to modify the compiler or flags, you can edit the variables at the top of the Makefile.

	READOLDME.md:
		# CTF (Context To File)

		## Purpose

		`ctf` is a command-line tool designed to capture the structure and content of a workspace (directory) and consolidate it into a single text file. This file can then be easily provided as context to AI models, allowing them to understand the project's layout and relevant code.

		## Usage

		```bash
		./ctf [options]
		```

		By default, `ctf` traverses the current directory (`.`) and creates a timestamped output file (e.g., `ctf-output-YYYYMMDD-HHMMSS.txt`) in the current directory, listing the directory structure.

		## Options

		* `--help`, `-h`: Show help message and exit
		* `--clear`: Delete previous `ctf-output` files in the current directory
		* `--content`, `-c` `[ext1 ext2 ...]`: Include content of files with specified extensions (e.g., `c`, `h`, `py`). If no extensions are provided, includes all text files.
		* `--include`, `-i` `[paths...]`: Include specific files or directories (default is current directory `.`)
		* `--exclude`, `-e` `[paths...]`: Exclude specific files or directories
		* `--git`, `-g`: Use `.gitignore` entries as exclude patterns
		* `--dir`, `-d` `DIR`: Output directory (default is current directory)
		* `--name`, `-n` `NAME`: Output filename (default is timestamped)
		* `--paste`, `-p` `API_KEY`: Upload output as GitHub Gist using the provided API key

		## Examples

		1. **Basic structure dump:**

		    ```bash
		    ./ctf
		    ```

		2. **Include content of C/H files and specific directories, excluding build directory:**

		    ```bash
		    ./ctf -c c h -i src include tests -e build
		    ```

		3. **Use .gitignore, include Python content, save to a specific file:**

		    ```bash
		    ./ctf -g -c py -n my_project_context -d ./output
		    ```

		4. **Upload output to GitHub Gist:**

		    ```bash
		    ./ctf -c c h -p YOUR_GITHUB_TOKEN
		    ```

		5. **Clean up previous outputs:**

		    ```bash
		    ./ctf --clear
		    ```

		## Building the Project

		### Dependencies

		This project requires the following libraries:

		* libcurl (for HTTP requests)
		* jansson (for JSON parsing)

		On Debian/Ubuntu systems, you can install these dependencies with:

		```bash
		sudo apt-get install libcurl4-openssl-dev libjansson-dev
		```

		### Build Instructions

		1. Clone the repository:
		  
		  ```bash
		  git clone https://github.com/trethore/Context-To-File
		  cd Context-To-File
		  ```
		  
		2. Build the project:
		  
		  ```bash
		  make
		  ```
		  
		  This will compile the source files and create the `ctf` executable.
		  
		3. To clean the build files:
		  
		  ```bash
		  make clean
		  ```

		### Build Configuration

		The project is compiled with the following flags:

		* `-Wall -Wextra`: Enable all warnings
		* `-std=c11`: Use C11 standard
		* `-g`: Include debugging information

		If you need to modify the compiler or flags, you can edit the variables at the top of the Makefile.
	doc/
		recap.1:
			.TH RECAP 1 "April 2025" "recap 1.0" "User Commands"
			.SH NAME
			recap \- capture the structure and content of a workspace and consolidate it into a single text output
			.SH SYNOPSIS
			.B recap
			[\fIOPTION\fR]...
			.SH DESCRIPTION
			A command-line tool designed to capture the structure and content of a workspace and consolidate it into a single text output. This output can be redirected to a file or piped directly, making it ideal for providing context to AI models that need to understand the project's layout and relevant code.
			.SH OPTIONS
			Mandatory arguments to long options are mandatory for short options too.
			.TP
			.B \-C, \-\-clear[=\fIDIR]
			remove previous recap-output files (optionally from DIR)
			.TP
			.B \-c, \-\-content=\fIEXTS
			include content of files with given the extensions
			.I EXTS
			is a comma-separated list of file extensions, without the leading dot
			.TP
			.B \-i, \-\-include=\fIPATH
			include a specific file or directory; can be repeated
			.TP
			.B \-e, \-\-exclude=\fIPATH
			exclude a specific file or directory; can be repeated
			.TP
			.B \-g, \-\-git
			attemps to open the file
			.I .gitignore
			in the current directory and load exclusions from it
			.TP
			.B \-p, \-\-paste[\=\fIGIST_API_KEY]
			upload output as GitHub Gist; if no argument is specified, it reads from the
			.I GIST_API_KEY
			environment variable
			.TP
			.B \-o, \-\-output=\fIFILE
			output to
			.I FILE
			.TP
			.B \-O, \-\-output-dir=\fIDIR
			output a timestampped file to
			.I DIR
			.TP
			.B \-h, \-\-help
			output a help message and exit
			.SH ENVIRONMENT
			.RS
			.TS
			tab(:);
			l l.
			GIST_API_KEY:GitHub Gist API key; expected when \fB\-\-paste\fR is passed without an argument.
			.TE
			.RE
			.SH EXIT STATUS
			0 on success, 1 on error. Errors are printed to standard error.
			.SH EXAMPLES
			.RS 4
			.TP
			.B recap src
			Process 'src’ directory
			.TP
			.B recap \-i src \-e test.txt
			Include 'src’ and exclude 'test.txt’
			.TP
			.B recap \-C
			Clear all recap-output files in the current directory
			.TP
			.B recap src \-c c \-o somedir/out.txt
			Process 'src’ with content specifier 'c’ to 'somedir/out.txt’
			.RE
			.SH AUTHOR
			Written by Trethore and Scover.
			.SH REPORTING BUGS
			Report issues at:
			.BR https://github.com/trethore/RECAP
			.SH SEE ALSO
			.if !d MR .ds MR \\fB\\$1\\fR(\\$2)
			.MR cat 1
	make.sh:
		rm recap
		make clean && make
	obj/
		args.o
		gist.o
		main.o
		traverse.o
		utils.o
	others/
		otherfile.txt:
			another file
	recap
	src/
		args.c:
			#define _POSIX_C_SOURCE 200809L
			#include "recap.h"
			#include <getopt.h>
			#include <unistd.h>
			#include <stdio.h>
			#include <stdlib.h>
			#include <string.h>
			#include <dirent.h>
			#include <ctype.h>
			#include <limits.h>

			static int add_regex(regex_ctx* ctx, const char* pattern) {
			    if (ctx->count >= MAX_PATTERNS) {
			        fprintf(stderr, "Error: Too many regex patterns. Max allowed is %d\n", MAX_PATTERNS);
			        return -1;
			    }
			    int ret = regcomp(&ctx->compiled[ctx->count], pattern, REG_EXTENDED | REG_NOSUB);
			    if (ret) {
			        char err_buf[256];
			        regerror(ret, &ctx->compiled[ctx->count], err_buf, sizeof(err_buf));
			        fprintf(stderr, "Error: Could not compile regex '%s': %s\n", pattern, err_buf);
			        return -1;
			    }
			    ctx->count++;
			    return 0;
			}

			void free_regex_ctx(regex_ctx* ctx) {
			    for (int i = 0; i < ctx->count; i++) {
			        regfree(&ctx->compiled[i]);
			    }
			    ctx->count = 0;
			}

			void clear_recap_output_files(const char* target_dir) {
			    const char* dir_to_open = (target_dir && *target_dir) ? target_dir : ".";
			    printf("Warning: This will delete every file matching 'recap-output*' in '%s'.\n", dir_to_open);
			    printf("Are you sure? (y/N): ");
			    int confirmation = getchar();
			    if (tolower(confirmation) != 'y') {
			        printf("Operation cancelled.\n");
			        return;
			    }
			    DIR* dir = opendir(dir_to_open);
			    if (!dir) {
			        perror("opendir for clearing");
			        return;
			    }
			    struct dirent* entry;
			    int count = 0;
			    while ((entry = readdir(dir)) != NULL) {
			        if (strncmp(entry->d_name, "recap-output", 12) == 0) {
			            char path[MAX_PATH_SIZE];
			            int len = snprintf(path, sizeof(path), "%s/%s", dir_to_open, entry->d_name);
			            if (len < 0 || (size_t)len >= sizeof(path)) {
			                fprintf(stderr, "Warning: path too long, skipping: %s/%s\n", dir_to_open, entry->d_name);
			                continue;
			            }
			            if (remove(path) == 0) {
			                printf("Deleted: %s\n", path);
			                count++;
			            }
			            else {
			                perror("remove recap-output file");
			            }
			        }
			    }
			    closedir(dir);
			    printf("Cleared %d file(s).\n", count);
			}

			void load_gitignore(recap_context* ctx, const char* gitignore_filename_arg) {
			    char path[MAX_PATH_SIZE];
			    strncpy(path, ctx->cwd, sizeof(path));
			    const char* filename = (gitignore_filename_arg && *gitignore_filename_arg) ? gitignore_filename_arg : ".gitignore";

			    while (1) {
			        char gitignore_path[MAX_PATH_SIZE];
			        int len = snprintf(gitignore_path, sizeof(gitignore_path), "%s/%s", path, filename);
			        if (len < 0 || (size_t)len >= sizeof(gitignore_path)) {
			            fprintf(stderr, "Warning: path too long, stopping gitignore search.\n");
			            break;
			        }

			        FILE* file = fopen(gitignore_path, "r");
			        if (file) {
			            char line[MAX_PATH_SIZE];
			            while (fgets(line, sizeof(line), file)) {
			                line[strcspn(line, "\r\n")] = 0;
			                char* trimmed = line;
			                while (isspace((unsigned char)*trimmed)) trimmed++;
			                if (*trimmed == '\0' || *trimmed == '#') continue;
			                if (ctx->fnmatch_exclude_filters.count < MAX_PATTERNS) {
			                    strncpy(ctx->gitignore_entries[ctx->gitignore_entry_count], trimmed, MAX_PATH_SIZE - 1);
			                    ctx->gitignore_entries[ctx->gitignore_entry_count][MAX_PATH_SIZE - 1] = '\0';
			                    ctx->fnmatch_exclude_filters.patterns[ctx->fnmatch_exclude_filters.count++] = ctx->gitignore_entries[ctx->gitignore_entry_count++];
			                }
			            }
			            fclose(file);
			            return;
			        }
			        char* sep = strrchr(path, '/');
			        if (sep == path || !sep) break;
			        *sep = '\0';
			    }
			}

			void print_help(const char* version) {
			    printf("Usage: recap [options] [path...]\n");
			    printf("  `path...` are the starting points for traversal (default: .)\n\n");
			    printf("Options:\n");
			    printf("  -h, --help                  Show this help message and exit\n");
			    printf("  -v, --version               Show version information (%s) and exit\n", version);
			    printf("  -C, --clear [DIR]           Clear recap-output files in [DIR] (default: .)\n\n");
			    printf("Filtering and Content:\n");
			    printf("  -i, --include <REGEX>       Include only paths that match REGEX.\n");
			    printf("  -e, --exclude <REGEX>       Exclude any path that matches REGEX.\n");
			    printf("  -I, --include-content <R>   Show content for files matching <R>.\n");
			    printf("  -E, --exclude-content <R>   Exclude content for files matching <R>.\n");
			    printf("  -s, --strip <REGEX>         Skip lines until a line matches REGEX.\n");
			    printf("  -g, --git [FILE]            Use .gitignore for exclusions.\n\n");
			    printf("Output and Upload:\n");
			    printf("  -p, --paste [KEY]           Upload output to Gist (uses GITHUB_API_KEY env var).\n");
			    printf("  -o, --output <FILE>         Specify the output file name.\n");
			    printf("  -O, --output-dir <DIR>      Specify the output directory.\n");
			}

			void parse_arguments(int argc, char* argv[], recap_context* ctx) {
			    ctx->fnmatch_exclude_filters.patterns[ctx->fnmatch_exclude_filters.count++] = ".git/";

			    static struct option long_options[] = {
			        {"help", no_argument, 0, 'h'}, {"version", no_argument, 0, 'v'},
			        {"clear", optional_argument, 0, 'C'}, {"include", required_argument, 0, 'i'},
			        {"exclude", required_argument, 0, 'e'}, {"include-content", required_argument, 0, 'I'},
			        {"exclude-content", required_argument, 0, 'E'}, {"strip", required_argument, 0, 's'},
			        {"git", optional_argument, 0, 'g'}, {"paste", optional_argument, 0, 'p'},
			        {"output", required_argument, 0, 'o'}, {"output-dir", required_argument, 0, 'O'},
			        {0, 0, 0, 0}
			    };

			    int opt;
			    while ((opt = getopt_long(argc, argv, "hvC::i:e:I:E:s:g::p::o:O:", long_options, NULL)) != -1) {
			        switch (opt) {
			        case 'h': print_help(ctx->version); exit(0);
			        case 'v': printf("recap version %s\n", ctx->version); exit(0);
			        case 'C': clear_recap_output_files(optarg); exit(0);
			        case 'i': add_regex(&ctx->include_filters, optarg); break;
			        case 'e': add_regex(&ctx->exclude_filters, optarg); break;
			        case 'I': add_regex(&ctx->content_include_filters, optarg); add_regex(&ctx->include_filters, optarg); break;
			        case 'E': add_regex(&ctx->content_exclude_filters, optarg); break;
			        case 's':
			            if (regcomp(&ctx->strip_regex, optarg, REG_EXTENDED | REG_NOSUB) == 0) {
			                ctx->strip_regex_is_set = 1;
			            }
			            else {
			                fprintf(stderr, "Error: Could not compile --strip regex '%s'\n", optarg);
			            }
			            break;
			        case 'g': load_gitignore(ctx, optarg); break;
			        case 'p': ctx->gist_api_key = optarg ? optarg : getenv("GITHUB_API_KEY"); if (!ctx->gist_api_key) ctx->gist_api_key = ""; break;
			        case 'o': strncpy(ctx->output.output_name, optarg, sizeof(ctx->output.output_name) - 1); break;
			        case 'O': strncpy(ctx->output.output_dir, optarg, sizeof(ctx->output.output_dir) - 1); break;
			        default: exit(1);
			        }
			    }

			    while (optind < argc) {
			        if (ctx->start_path_count < MAX_PATTERNS) {
			            ctx->start_paths[ctx->start_path_count++] = argv[optind++];
			        }
			        else {
			            fprintf(stderr, "Error: Too many start paths specified.\n");
			            exit(1);
			        }
			    }

			    if (ctx->start_path_count == 0) {
			        ctx->start_paths[ctx->start_path_count++] = ".";
			    }
			}
		gist.c:
			#define _POSIX_C_SOURCE 200809L
			#include "recap.h"
			#include <curl/curl.h>
			#include <jansson.h>
			#include <string.h>
			#include <stdlib.h>

			#define GIST_API_URL "https://api.github.com/gists"
			#define GIST_USER_AGENT "recap-c-tool/2.0"
			#define GIST_MAX_FILESIZE (10 * 1024 * 1024) // 10 MB

			struct MemoryStruct {
			    char* memory;
			    size_t size;
			};

			static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {
			    size_t realsize = size * nmemb;
			    struct MemoryStruct* mem = (struct MemoryStruct*)userp;

			    char* ptr = realloc(mem->memory, mem->size + realsize + 1);
			    if (ptr == NULL) {
			        fprintf(stderr, "Gist upload: not enough memory (realloc returned NULL)\n");
			        return 0;
			    }

			    mem->memory = ptr;
			    memcpy(&(mem->memory[mem->size]), contents, realsize);
			    mem->size += realsize;
			    mem->memory[mem->size] = 0;
			    return realsize;
			}

			static char* read_file_content(const char* filepath, long* filesize) {
			    FILE* file = fopen(filepath, "rb");
			    if (!file) {
			        perror("fopen for gist upload");
			        return NULL;
			    }

			    char* content = malloc(*filesize + 1);
			    if (!content) {
			        fprintf(stderr, "Gist upload error: Memory allocation failed for file content.\n");
			        fclose(file);
			        return NULL;
			    }

			    if (fread(content, 1, *filesize, file) != (size_t)*filesize) {
			        fprintf(stderr, "Gist upload error: Error reading file %s.\n", filepath);
			        free(content);
			        fclose(file);
			        return NULL;
			    }

			    content[*filesize] = '\0';
			    fclose(file);
			    return content;
			}

			static char* create_gist_payload(const char* filename, const char* content) {
			    json_t* root, * files_obj, * file_obj;
			    root = json_object();
			    files_obj = json_object();
			    file_obj = json_object();

			    if (!root || !files_obj || !file_obj) {
			        fprintf(stderr, "Gist upload error: Failed to create JSON objects.\n");
			        json_decref(root); json_decref(files_obj); json_decref(file_obj);
			        return NULL;
			    }

			    json_object_set_new(file_obj, "content", json_string(content));
			    json_object_set_new(files_obj, filename, file_obj);
			    json_object_set_new(root, "description", json_string("Recap output"));
			    json_object_set_new(root, "public", json_false());
			    json_object_set_new(root, "files", files_obj);

			    char* payload = json_dumps(root, JSON_COMPACT);
			    json_decref(root);
			    return payload;
			}

			char* upload_to_gist(const char* filepath, const char* github_token) {
			    struct stat st;
			    if (stat(filepath, &st) != 0 || !S_ISREG(st.st_mode)) {
			        fprintf(stderr, "Gist upload error: Input is not a valid file: %s\n", filepath);
			        return NULL;
			    }
			    if (st.st_size <= 0) {
			        fprintf(stderr, "Gist upload info: Input file '%s' is empty. Skipping.\n", filepath);
			        return NULL;
			    }
			    if (st.st_size > GIST_MAX_FILESIZE) {
			        fprintf(stderr, "Gist upload error: File '%s' is too large.\n", filepath);
			        return NULL;
			    }

			    char* file_content = read_file_content(filepath, &st.st_size);
			    if (!file_content) return NULL;

			    const char* filename_only = strrchr(filepath, '/');
			    filename_only = filename_only ? filename_only + 1 : filepath;

			    char* json_payload = create_gist_payload(filename_only, file_content);
			    free(file_content);
			    if (!json_payload) return NULL;

			    CURL* curl = NULL;
			    struct curl_slist* headers = NULL;
			    struct MemoryStruct chunk = { .memory = malloc(1), .size = 0 };
			    char* html_url = NULL;

			    if (!chunk.memory) goto cleanup;
			    chunk.memory[0] = '\0';

			    curl = curl_easy_init();
			    if (!curl) goto cleanup;

			    char auth_header[512];
			    snprintf(auth_header, sizeof(auth_header), "Authorization: token %s", github_token);

			    headers = curl_slist_append(headers, auth_header);
			    headers = curl_slist_append(headers, "Content-Type: application/json");
			    headers = curl_slist_append(headers, "Accept: application/vnd.github.v3+json");
			    headers = curl_slist_append(headers, "User-Agent: " GIST_USER_AGENT);

			    curl_easy_setopt(curl, CURLOPT_URL, GIST_API_URL);
			    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, json_payload);
			    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
			    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
			    curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&chunk);
			    curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1L);

			    if (curl_easy_perform(curl) == CURLE_OK) {
			        json_error_t error;
			        json_t* response_json = json_loadb(chunk.memory, chunk.size, 0, &error);
			        if (response_json) {
			            json_t* url_json = json_object_get(response_json, "html_url");
			            if (json_is_string(url_json)) {
			                html_url = strdup(json_string_value(url_json));
			            }
			            json_decref(response_json);
			        }
			    }
			    else {
			        fprintf(stderr, "Gist upload error: curl_easy_perform() failed.\n");
			        long http_code = 0;
			        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);
			        fprintf(stderr, "HTTP response code: %ld. Response: %.*s\n", http_code, (int)chunk.size, chunk.memory);
			    }

			cleanup:
			    free(chunk.memory);
			    free(json_payload);
			    curl_slist_free_all(headers);
			    curl_easy_cleanup(curl);
			    return html_url;
			}
		main.c:
			#define _POSIX_C_SOURCE 200809L
			#include "recap.h"
			#include <curl/curl.h>
			#include <string.h>
			#include <stdlib.h>
			#include <stdio.h>
			#include <unistd.h>

			const char* RECAP_VERSION = "2.0.0";

			static int setup_output_stream(recap_context* ctx) {
			    if (ctx->output.output_name[0] == '\0' && ctx->output.output_dir[0] == '\0') {
			        ctx->output.use_stdout = 1;
			        ctx->output_stream = stdout;
			    }
			    else {
			        ctx->output.use_stdout = 0;
			        if (generate_output_filename(&ctx->output) != 0) {
			            return 1;
			        }
			        ctx->output_stream = fopen(ctx->output.calculated_output_path, "w");
			        if (!ctx->output_stream) {
			            perror("fopen output file");
			            fprintf(stderr, "Error: Could not open output file: %s\n", ctx->output.calculated_output_path);
			            return 1;
			        }
			    }
			    return 0;
			}

			static void handle_post_processing(recap_context* ctx) {
			    if (ctx->items_processed_count == 0) {
			        if (!ctx->output.use_stdout) {
			            fprintf(stderr, "Info: No files matched criteria. Removing empty output file: %s\n", ctx->output.calculated_output_path);
			            remove(ctx->output.calculated_output_path);
			        }
			        else {
			            fprintf(stderr, "Info: No files matched the criteria to be processed.\n");
			        }
			        return;
			    }

			    if (ctx->gist_api_key != NULL) {
			        if (ctx->gist_api_key[0] == '\0') {
			            fprintf(stderr, "Error: Gist upload requested, but no API key found.\n");
			            if (!ctx->output.use_stdout) {
			                fprintf(stderr, "Output saved locally to %s\n", ctx->output.calculated_output_path);
			            }
			        }
			        else if (ctx->output.use_stdout) {
			            fprintf(stderr, "Warning: Cannot upload to Gist when outputting to stdout.\n");
			        }
			        else {
			            printf("Uploading to Gist...\n");
			            char* gist_url = upload_to_gist(ctx->output.calculated_output_path, ctx->gist_api_key);
			            if (gist_url) {
			                printf("Output uploaded to: %s\n", gist_url);
			                free(gist_url);
			                remove(ctx->output.calculated_output_path);
			            }
			            else {
			                fprintf(stderr, "Failed to upload to Gist. Output saved locally to %s\n", ctx->output.calculated_output_path);
			            }
			        }
			    }
			    else if (!ctx->output.use_stdout) {
			        printf("Output written to %s\n", ctx->output.calculated_output_path);
			    }
			}

			int main(int argc, char* argv[]) {
			    recap_context ctx = { 0 };
			    int result = 0;

			    ctx.version = RECAP_VERSION;

			    if (!getcwd(ctx.cwd, sizeof(ctx.cwd))) {
			        perror("Failed to get current working directory");
			        return 1;
			    }
			    normalize_path(ctx.cwd);

			    if (curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
			        fprintf(stderr, "Error: Failed to initialize libcurl.\n");
			        return 1;
			    }

			    parse_arguments(argc, argv, &ctx);

			    if (setup_output_stream(&ctx) != 0) {
			        result = 1;
			        goto cleanup;
			    }

			    start_traversal(&ctx);

			    if (ctx.output_stream && ctx.output_stream != stdout) {
			        fclose(ctx.output_stream);
			        ctx.output_stream = NULL;
			    }

			    handle_post_processing(&ctx);

			cleanup:
			    if (ctx.output_stream && ctx.output_stream != stdout) {
			        fclose(ctx.output_stream);
			    }
			    free_regex_ctx(&ctx.include_filters);
			    free_regex_ctx(&ctx.exclude_filters);
			    free_regex_ctx(&ctx.content_include_filters);
			    free_regex_ctx(&ctx.content_exclude_filters);
			    if (ctx.strip_regex_is_set) {
			        regfree(&ctx.strip_regex);
			    }
			    curl_global_cleanup();
			    return result;
			}
		recap.h:
			#ifndef RECAP_H
			#define RECAP_H

			#include <stdio.h>
			#include <regex.h>
			#include <sys/stat.h>

			#define MAX_PATH_SIZE 4096
			#define MAX_PATTERNS 256
			#define MAX_GITIGNORE_ENTRIES 1024

			typedef struct {
			    regex_t compiled[MAX_PATTERNS];
			    int count;
			} regex_ctx;

			typedef struct {
			    const char* patterns[MAX_PATTERNS];
			    int count;
			} fnmatch_ctx;

			typedef struct {
			    char output_dir[MAX_PATH_SIZE];
			    char output_name[MAX_PATH_SIZE];
			    char calculated_output_path[MAX_PATH_SIZE];
			    char relative_output_path[MAX_PATH_SIZE];
			    int use_stdout;
			} output_ctx;

			typedef struct {
			    const char* start_paths[MAX_PATTERNS];
			    int start_path_count;
			    int items_processed_count;
			    char cwd[MAX_PATH_SIZE];

			    regex_ctx include_filters;
			    regex_ctx exclude_filters;
			    regex_ctx content_include_filters;
			    regex_ctx content_exclude_filters;

			    fnmatch_ctx fnmatch_exclude_filters;
			    char gitignore_entries[MAX_GITIGNORE_ENTRIES][MAX_PATH_SIZE];
			    int gitignore_entry_count;

			    regex_t strip_regex;
			    int strip_regex_is_set;

			    output_ctx output;
			    const char* gist_api_key;
			    const char* version;
			    FILE* output_stream;
			} recap_context;

			void parse_arguments(int argc, char* argv[], recap_context* ctx);
			void load_gitignore(recap_context* ctx, const char* gitignore_filename);
			void clear_recap_output_files(const char* target_dir);
			void free_regex_ctx(regex_ctx* ctx);

			int start_traversal(recap_context* ctx);

			int is_text_file(const char* full_path);
			void normalize_path(char* path);
			int generate_output_filename(output_ctx* output_context);
			void get_relative_path(const char* full_path, const char* cwd, char* rel_path_out, size_t size);

			char* upload_to_gist(const char* filepath, const char* github_token);

			#endif
		traverse.c:
			#define _POSIX_C_SOURCE 200809L
			#include "recap.h"
			#include <dirent.h>
			#include <errno.h>
			#include <fnmatch.h>
			#include <limits.h>
			#include <stdlib.h>
			#include <string.h>
			#include <unistd.h>

			static int match_regex_list(const regex_ctx* ctx, const char* str) {
			    for (int i = 0; i < ctx->count; i++) {
			        if (regexec(&ctx->compiled[i], str, 0, NULL, 0) == 0) return 1;
			    }
			    return 0;
			}

			static int match_fnmatch_list(const fnmatch_ctx* ctx, const char* path_to_check) {
			    for (int i = 0; i < ctx->count; i++) {
			        const char* pattern = ctx->patterns[i];
			        if (fnmatch(pattern, path_to_check, FNM_PATHNAME | FNM_PERIOD) == 0) return 1;
			        size_t len = strlen(pattern);
			        if (len > 0 && pattern[len - 1] == '/') {
			            if (strncmp(path_to_check, pattern, len) == 0) return 1;
			        }
			    }
			    return 0;
			}

			static int should_be_skipped(const char* rel_path, const struct stat* st, recap_context* ctx) {
			    if (!ctx->output.use_stdout && strcmp(rel_path, ctx->output.relative_output_path) == 0) return 1;
			    if (match_fnmatch_list(&ctx->fnmatch_exclude_filters, rel_path)) return 1;
			    if (ctx->exclude_filters.count > 0 && match_regex_list(&ctx->exclude_filters, rel_path)) return 1;

			    if (ctx->include_filters.count > 0) {
			        if (match_regex_list(&ctx->include_filters, rel_path)) return 0;
			        char temp_path[MAX_PATH_SIZE];
			        strncpy(temp_path, rel_path, sizeof(temp_path) - 1);
			        temp_path[sizeof(temp_path) - 1] = '\0';
			        for (char* p = strrchr(temp_path, '/'); p; p = strrchr(temp_path, '/')) {
			            *p = '\0';
			            if (match_regex_list(&ctx->include_filters, temp_path)) return 0;
			        }
			        return S_ISDIR(st->st_mode) ? 0 : 1;
			    }
			    return 0;
			}

			int should_show_content(const char* rel_path, const char* full_path, recap_context* ctx) {
			    if (ctx->content_exclude_filters.count > 0 && match_regex_list(&ctx->content_exclude_filters, rel_path)) return 0;
			    if (ctx->content_include_filters.count > 0) {
			        if (match_regex_list(&ctx->content_include_filters, rel_path)) {
			            return is_text_file(full_path);
			        }
			    }
			    return 0;
			}

			void print_indent(int depth, FILE* output) {
			    for (int i = 0; i < depth; i++) {
			        fputc('\t', output);
			    }
			}

			void write_file_content(const char* filepath, int depth, recap_context* ctx) {
			    FILE* f = fopen(filepath, "r");
			    if (!f) {
			        print_indent(depth, ctx->output_stream);
			        fprintf(ctx->output_stream, "[Error reading file content]\n");
			        return;
			    }

			    char line[4096];
			    int header_stripped = !ctx->strip_regex_is_set;
			    int previous_line_was_blank = 0;

			    while (fgets(line, sizeof(line), f)) {
			        if (!header_stripped) {
			            if (regexec(&ctx->strip_regex, line, 0, NULL, 0) == 0) {
			                header_stripped = 1;
			            }
			            continue;
			        }

			        size_t len = strlen(line);
			        while (len > 0 && (line[len - 1] == '\n' || line[len - 1] == '\r')) {
			            line[--len] = '\0';
			        }

			        if (len == 0) {
			            if (!previous_line_was_blank) {
			                fputc('\n', ctx->output_stream);
			                previous_line_was_blank = 1;
			            }
			        }
			        else {
			            previous_line_was_blank = 0;
			            print_indent(depth, ctx->output_stream);
			            fputs(line, ctx->output_stream);
			            fputc('\n', ctx->output_stream);
			        }
			    }
			    fclose(f);
			}

			void traverse_directory(const char* base_path, const char* rel_path_prefix, int depth, recap_context* ctx) {
			    DIR* dir = opendir(base_path);
			    if (!dir) return;

			    struct dirent** namelist;
			    int n = scandir(base_path, &namelist, NULL, alphasort);
			    if (n < 0) {
			        closedir(dir);
			        return;
			    }

			    for (int i = 0; i < n; i++) {
			        struct dirent* entry = namelist[i];
			        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
			            free(namelist[i]);
			            continue;
			        }

			        char full_path[MAX_PATH_SIZE], rel_path[MAX_PATH_SIZE];
			        int len;

			        len = snprintf(full_path, sizeof(full_path), "%s/%s", base_path, entry->d_name);
			        if (len < 0 || (size_t)len >= sizeof(full_path)) {
			            free(namelist[i]);
			            continue;
			        }
			        len = snprintf(rel_path, sizeof(rel_path), "%s%s", rel_path_prefix, entry->d_name);
			        if (len < 0 || (size_t)len >= sizeof(rel_path)) {
			            free(namelist[i]);
			            continue;
			        }
			        struct stat st;
			        if (lstat(full_path, &st) != 0) {
			            free(namelist[i]);
			            continue;
			        }
			        if (should_be_skipped(rel_path, &st, ctx)) {
			            free(namelist[i]);
			            continue;
			        }

			        ctx->items_processed_count++;
			        print_indent(depth, ctx->output_stream);

			        if (S_ISDIR(st.st_mode)) {
			            fprintf(ctx->output_stream, "%s/\n", entry->d_name);
			            char next_rel_prefix[MAX_PATH_SIZE];
			            len = snprintf(next_rel_prefix, sizeof(next_rel_prefix), "%s/", rel_path);
			            if (len >= 0 && (size_t)len < sizeof(next_rel_prefix)) {
			                traverse_directory(full_path, next_rel_prefix, depth + 1, ctx);
			            }
			        }
			        else if (S_ISLNK(st.st_mode)) {
			            fprintf(ctx->output_stream, "%s@\n", entry->d_name);
			        }
			        else if (S_ISREG(st.st_mode)) {
			            if (should_show_content(rel_path, full_path, ctx)) {
			                fprintf(ctx->output_stream, "%s:\n", entry->d_name);
			                write_file_content(full_path, depth + 1, ctx);
			            }
			            else {
			                fprintf(ctx->output_stream, "%s\n", entry->d_name);
			            }
			        }
			        free(namelist[i]);
			    }
			    free(namelist);
			    closedir(dir);
			}

			int start_traversal(recap_context* ctx) {
			    for (int i = 0; i < ctx->start_path_count; i++) {
			        char path[MAX_PATH_SIZE], rel_path[MAX_PATH_SIZE];
			        strncpy(path, ctx->start_paths[i], sizeof(path) - 1);
			        path[sizeof(path) - 1] = '\0';
			        normalize_path(path);

			        get_relative_path(path, ctx->cwd, rel_path, sizeof(rel_path));

			        struct stat st;
			        if (lstat(path, &st) != 0) {
			            fprintf(stderr, "Warning: Could not stat start path: %s\n", ctx->start_paths[i]);
			            continue;
			        }

			        if (should_be_skipped(rel_path, &st, ctx)) continue;

			        ctx->items_processed_count++;
			        const char* basename = strrchr(path, '/');
			        basename = basename ? basename + 1 : path;

			        if (S_ISDIR(st.st_mode)) {
			            fprintf(ctx->output_stream, "%s/\n", strcmp(path, ".") == 0 ? "." : basename);
			            char rel_prefix[MAX_PATH_SIZE];
			            int len;
			            if (strcmp(rel_path, ".") == 0) {
			                rel_prefix[0] = '\0';
			                len = 0;
			            }
			            else {
			                len = snprintf(rel_prefix, sizeof(rel_prefix), "%s/", rel_path);
			            }

			            if (len >= 0 && (size_t)len < sizeof(rel_prefix)) {
			                traverse_directory(path, rel_prefix, 1, ctx);
			            }
			        }
			        else if (S_ISREG(st.st_mode)) {
			            if (should_show_content(rel_path, path, ctx)) {
			                fprintf(ctx->output_stream, "%s:\n", basename);
			                write_file_content(path, 1, ctx);
			            }
			            else {
			                fprintf(ctx->output_stream, "%s\n", basename);
			            }
			        }
			    }
			    return 0;
			}
		utils.c:
			#define _POSIX_C_SOURCE 200809L
			#include "recap.h"
			#include <ctype.h>
			#include <errno.h>
			#include <stdio.h>
			#include <stdlib.h>
			#include <string.h>
			#include <time.h>
			#include <unistd.h>

			int is_text_file(const char* full_path) {
			    FILE* file = fopen(full_path, "rb");
			    if (!file) return 0;
			    unsigned char buffer[1024];
			    size_t bytes_read = fread(buffer, 1, sizeof(buffer), file);
			    fclose(file);
			    if (bytes_read == 0) return 1;
			    for (size_t i = 0; i < bytes_read; i++) {
			        if (buffer[i] == '\0') return 0;
			    }
			    return 1;
			}

			void normalize_path(char* path) {
			    if (!path || path[0] == '\0') return;
			    char* p = path;
			    char* q = path;
			    size_t len = strlen(path);
			    if (len > 1 && path[len - 1] == '/') path[len - 1] = '\0';
			    char** components = malloc(len * sizeof(char*));
			    if (!components) return;
			    int i = 0;
			    if (*p == '/') {
			        q++;
			        p++;
			    }
			    while (*p) {
			        if (*p == '/') {
			            *p = '\0';
			            components[i++] = q;
			            q = p + 1;
			        }
			        p++;
			    }
			    components[i++] = q;
			    int top = 0;
			    for (int j = 0; j < i; j++) {
			        if (strcmp(components[j], ".") == 0) continue;
			        if (strcmp(components[j], "..") == 0) {
			            if (top > 0) top--;
			        }
			        else {
			            components[top++] = components[j];
			        }
			    }
			    p = path;
			    if (path[0] == '/') *p++ = '/';
			    for (int j = 0; j < top; j++) {
			        size_t component_len = strlen(components[j]);
			        memmove(p, components[j], component_len);
			        p += component_len;
			        if (j < top - 1) *p++ = '/';
			    }
			    *p = '\0';
			    if (path[0] == '\0') strcpy(path, ".");
			    free(components);
			}

			void get_relative_path(const char* full_path, const char* cwd, char* rel_path_out, size_t size) {
			    char normalized_full_path[MAX_PATH_SIZE];
			    strncpy(normalized_full_path, full_path, sizeof(normalized_full_path) - 1);
			    normalized_full_path[sizeof(normalized_full_path) - 1] = '\0';
			    normalize_path(normalized_full_path);

			    if (normalized_full_path[0] != '/') {
			        snprintf(rel_path_out, size, "%s", normalized_full_path);
			        return;
			    }

			    size_t cwd_len = strlen(cwd);
			    if (strncmp(normalized_full_path, cwd, cwd_len) == 0) {
			        const char* p = normalized_full_path + cwd_len;
			        if (*p == '/') p++;
			        snprintf(rel_path_out, size, "%s", *p ? p : ".");
			    }
			    else {
			        snprintf(rel_path_out, size, "%s", normalized_full_path);
			    }
			}

			int generate_output_filename(output_ctx* ctx) {
			    char combined_path[MAX_PATH_SIZE];
			    const char* dir = (strlen(ctx->output_dir) > 0) ? ctx->output_dir : ".";
			    int len;

			    if (strlen(ctx->output_name) > 0) {
			        len = snprintf(combined_path, sizeof(combined_path), "%s/%s", dir, ctx->output_name);
			    }
			    else {
			        time_t now = time(NULL);
			        struct tm* t = localtime(&now);
			        char timestamp[64];
			        strftime(timestamp, sizeof(timestamp), "recap-output-%Y%m%d-%H%M%S.txt", t);
			        len = snprintf(combined_path, sizeof(combined_path), "%s/%s", dir, timestamp);
			    }

			    if (len < 0 || (size_t)len >= sizeof(combined_path)) {
			        fprintf(stderr, "Error: Constructed output path is too long.\n");
			        return -1;
			    }

			    normalize_path(combined_path);
			    strncpy(ctx->calculated_output_path, combined_path, MAX_PATH_SIZE - 1);
			    ctx->calculated_output_path[MAX_PATH_SIZE - 1] = '\0';

			    char cwd[MAX_PATH_SIZE];
			    if (getcwd(cwd, sizeof(cwd))) {
			        normalize_path(cwd);
			        get_relative_path(ctx->calculated_output_path, cwd, ctx->relative_output_path, sizeof(ctx->relative_output_path));
			    }
			    else {
			        strncpy(ctx->relative_output_path, ctx->calculated_output_path, sizeof(ctx->relative_output_path));
			    }
			    return 0;
			}
	test/
		folder1/
			Dockerfile:
				FROM "archLinux/archlinux"
			index.html:
				<!DOCTYPE html>
				<html lang="en">
				<head>
				    <meta charset="UTF-8">
				    <meta name="viewport" content="width=device-width, initial-scale=1.0">
				    <title>Test</title>
				</head>
				<body>
				    <h1>this is a test</h1>
				</body>
				</html>
			main.js:
				function test() {
				    console.log("This is a test");
				}

				test();
		folder2/
			index.ts:
				const toto:String = "toto";

				console.log(toto);
			nope:
				nope
			toto.exe:
		folder3/
			example.md:
				# This is an examples
			test
			test.c:
				#include <stdio.h>
				#include <stdlib.h>
				// this is a test
				int main() {
				    printf("This is a test\n");
				    return EXIT_SUCCESS;   
				}
